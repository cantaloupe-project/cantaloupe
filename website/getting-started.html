<h2>Getting Started</h2>

<h3 id="Requirements">Requirements</h3>

<p>The only hard requirement is Java 7+. Particular <a href="processors.html">processors</a> may have additional requirements.</p>

<h3 id="Configuration">Configuration</h3>

<p>Cantaloupe comes bundled with a sample configuration file, named <span class="filename">cantaloupe.properties.sample</span>. <strong>Do not edit this file</strong>, but rather create a copy and edit that. (Most of the documentation assumes a configuration file named <span class="filename">cantaloupe.properties</span>, but any name will work.)</p>

<p>The primary source of documentation of configuration file options are the comments within the file itself.</p>

<h3 id="Running">Running</h3>

<p>From the command prompt:</p>

<p><code>$ java -Dcantaloupe.config=/path/to/cantaloupe.properties -jar Cantaloupe-x.x.x.jar</code></p>

<p>Assuming the <code>http.port</code> option has not been changed, it is now running at: <a href="http://localhost:8182/iiif">http://localhost:8182/iiif</a></p>

<h3 id="Upgrading">Upgrading</h3>

<p>Upgrading is usually just a matter of downloading a new version and running it. Since instances are self-contained, new versions can run happily alongside existing ones, with each using its own config file. Sometimes there are backwards-incompatible changes to the configuration file structure, though, so check below to see if there is anything more to be done.</p>

<h4>1.0-beta3 to 1.0-beta4</h4>

<ul>
  <li>Add the <code>logging.*</code> keys from the sample configuration.</li>
  <li>Add the <code>generate_https_links</code> key from the sample configuration.</li>
  <li>Rename <code>HttpResolver.username</code> to <code>HttpResolver.auth.basic.username</code> in the configuration.</li>
  <li>Rename <code>HttpResolver.password</code> to <code>HttpResolver.auth.basic.secret</code> in the
  configuration.</li>
</ul>

<h4>1.0-beta2 to 1.0-beta3</h4>

<ul>
  <li>Rename the <code>cache</code> key in the configuration to <code>cache.server</code>.</li>
  <li>Add the <code>cache.client.*</code> keys from the sample configuration.</li>
  <li>Add the <code>http.auth.basic*</code> keys from the sample configuration.</li>
  <li>Add the <code>KakaduProcessor</code> keys from the sample configuration.</li>
  <li>Change any <code>ImageIoProcessor</code> references to <code>Java2dProcessor</code> in the configuration.</li>
  <li>Add the <code>Java2dProcessor.tif.reader</code> key from the sample configuration.</li>
</ul>

<h4>1.0-beta1 to 1.0-beta2</h4>

<ul>
  <li>Add the <code>cache</code> and <code>FilesystemCache.*</code> keys from the sample configuration.</li>
  <li>Add the <code>FilesystemResolver.path_separator</code> and <code>HttpResolver.path_separator</code> keys from the sample configuration.</li>
</ul>

<h3 id="Considerations">Considerations</h3>

<h4>CPU</h4>

<p>Generally, response times benefit from multiple fast CPU cores. Even if a particular processor doesn't support multithreading, the OS is at least likely to schedule different processing threads (from simultaneous requests) on different cores.</p>

<h4 id="Memory">Memory</h4>

<p>Consider the case of an image server that is asked to render tiles for a 4096x4096 pixel source image that, at 24 bits per pixel, totals 50MB in
decompressed size. Multiple clients are simultaneously requesting numerous downscaled tiles. Request handlers do not communicate with each other, so each one is loading this large image and operating on it independently.</p>

<p>Furthermore, some processors are inefficient in that they have to create new images internally at each intermediate step in the processing pipeline (cropping, scaling, rotating, etc.). Each one occupies precious memory.</p>

<p>It's easy to see where RAM becomes a very major consideration here. With the processors that do their work in Java, It is completely normal to see transient spikes of hundreds of megabytes of memory use on the Java heap in response to a single zooming-image-viewer request. The JVM will accommodate by dynamically increasing the heap size. From the operating system's perspective, the process is bloating up to multiple gigabytes in size, but there is nothing wrong &emdash; most of this is actually unused heap space.</p>

<p>The smaller the available heap space, the larger the source images, and the larger the number of simultaneous requests, the greater the likelihood of OutOfMemoryErrors. In production, it is highly recommended to use the <code>-Xmx</code> flag to increase the maximum heap size to the largest amount possible &emdash; for example, <code>-Xmx8g</code> for 8GB. And, by all means, use caching liberally.</p>

<h4>Storage</h4>

<p>Cantaloupe benefits from high-speed read performance in the underlying storage system.</p>
