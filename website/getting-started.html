---
layout: default
---

<h2>Getting Started</h2>

<h3 id="Requirements">Requirements</h3>

<p>The only hard requirement is Java 7+. Particular <a href="processors.html">processors</a> may have additional requirements.</p>

<h3 id="Download">Download</h3>

<p><a href="https://github.com/medusa-project/cantaloupe/releases">Download the latest release from GitHub.</a></p>

<h3 id="Configuration">Configuration</h3>

<p>The Cantaloupe .zip file bundles a sample configuration file, named <span class="filename">cantaloupe.properties.sample</span>. <strong>Do not edit this file</strong> &mdash; instead, create a copy and edit that. (These instructions assume a name of <span class="filename">cantaloupe.properties</span>, but any name will work.)</p>

<h3 id="Running">Running</h3>

<p>From the command prompt:</p>

<pre>$ java -Dcantaloupe.config=/path/to/cantaloupe.properties -jar Cantaloupe-x.x.x.jar</pre>

<p>Assuming the <code>http.port</code> option has not been changed, it is now running at: <a href="http://localhost:8182/">http://localhost:8182/</a></p>

<p><em>Note: On OS X, a "java" icon will appear in the Dock. This can be disabled by adding <code>-Djava.awt.headless=true</code> to the command.</em></p>

<h3 id="Upgrading">Upgrading</h3>

<p>Upgrading is usually just a matter of downloading a new version and running it. Since instances are self-contained, new versions can run happily alongside existing ones, with each using its own config file. Sometimes there are backwards-incompatible changes to the configuration file structure, though, so check below to see if there is anything more to be done.</p>

<h4>1.2 to 2.0</h4>

<div class="alert alert-warning">
  <p>Note that the Image API 2.0 endpoint, which used to be located at <span class="filename">/iiif</span>, has moved to <span class="filename">/iiif/2.0</a>.</p>
  <p>Likewise, the landing page, which used to be located at <span class="filename">/iiif</span>, has moved to <span class="filename">/</span>.</p>
</div>

<ul>
  <li>Because the cache naming format has changed, it will be necessary to clear your cache. (Failing to do this won't hurt anything, but any existing cached images will just sit there wasting space.)</li>
</ul>

<h4>1.1 to 1.2</h4>

<ul>
  <li>Add the <code>http.content_disposition</code> key from the sample configuration.</li>
  <li>Add the <code>AmazonS3Resolver.*</code> keys from the sample configuration.</li>
  <li>Add the <code>FfmpegProcessor.path_to_binaries</code> key from the sample configuration.</li>
  <li>Add the <code>cache.server.resolve_first</code> key from the sample configuration.</li>
  <li>Remove the <code>generate_https_links</code> key from your configuration file, and add the <code>base_uri</code> key from the sample configuration.</li>
</ul>

<h4>1.0.x to 1.1</h4>

<ul>
  <li>Add the <code>cache.client.enabled</code> key from the sample configuration.</li>
</ul>

<h4>1.0-beta3 to 1.0</h4>

<ul>
  <li>Add the <code>logging.*</code> keys from the sample configuration.</li>
  <li>Add the <code>generate_https_links</code> key from the sample configuration.</li>
  <li>Add the <code>FfmpegProcessor.path_to_binaries</code> key from the sample configuration.
  <li>Rename <code>HttpResolver.username</code> to <code>HttpResolver.auth.basic.username</code> in the configuration.</li>
  <li>Rename <code>HttpResolver.password</code> to <code>HttpResolver.auth.basic.secret</code> in the
  configuration.</li>
</ul>

<h4>1.0-beta2 to 1.0-beta3</h4>

<ul>
  <li>Rename the <code>cache</code> key in the configuration to <code>cache.server</code>.</li>
  <li>Add the <code>cache.client.*</code> keys from the sample configuration.</li>
  <li>Add the <code>http.auth.basic*</code> keys from the sample configuration.</li>
  <li>Add the <code>KakaduProcessor</code> keys from the sample configuration.</li>
  <li>Change any <code>ImageIoProcessor</code> references to <code>Java2dProcessor</code> in the configuration.</li>
  <li>Add the <code>Java2dProcessor.tif.reader</code> key from the sample configuration.</li>
</ul>

<h4>1.0-beta1 to 1.0-beta2</h4>

<ul>
  <li>Add the <code>cache</code> and <code>FilesystemCache.*</code> keys from the sample configuration.</li>
  <li>Add the <code>FilesystemResolver.path_separator</code> and <code>HttpResolver.path_separator</code> keys from the sample configuration.</li>
</ul>

<h3 id="Proxying">Proxying</h3>

<p>Cantaloupe can be set up to run behind a reverse-proxy web server like Apache or nginx. The following example should be able to get you most of the way toward a working Apache reverse proxy. It assumes that Cantaloupe is running on a server called <span class="filename">image-server.example.org</span> on port 8182; the reverse proxy is running on <span class="filename">www.example.org</span>; and Cantaloupe is to be made available at the <span class="filename">/images</span> base path.</p>

<p>First, set <code>base_uri</code> in the Cantaloupe configuration file to the publicly-visible base URI:

<pre>base_uri = http://www.example.org/images</pre>

<p>Then, add something like the following to your Apache reverse proxy configuration:</p>

<pre>&lt;VirtualHost *:80&gt;
    ServerName www.example.org
    ProxyPass /images/ http://image-server.example.org:8182/
    ProxyPassReverse /images/ http://image-server.example.org:8182/
    ProxyPassReverseCookiePath / /
    ProxyPassReverseCookieDomain image-server.example.org:8182 localhost
&lt;/VirtualHost&gt;
</pre>

<p><span class="filename">http://www.example.org/images/</span> now displays the Cantaloupe landing page.</p>

<h3 id="Considerations">Considerations</h3>

<h4>CPU</h4>

<p>Generally, response times benefit from multiple fast CPU cores. Even if a particular processor doesn't support multithreading, the operating system is at least likely to schedule different processing threads (from simultaneous requests) on different cores.</p>

<p>A 64-bit CPU is also important, as it enables Cantaloupe to use more memory.</p>

<h4 id="Memory">Memory</h4>

<p>Consider the case of an image server that is asked to render tiles for a 4096x4096 pixel source image that, at 24 bits per pixel, totals 50MB in
decompressed size. Multiple clients are simultaneously requesting numerous downscaled tiles. Request handlers do not communicate with each other, so each one is loading this large image and operating on it independently.</p>

<p>Furthermore, some processors are inefficient in that they have to create new images internally at each intermediate step in the processing pipeline (cropping, scaling, rotating, etc.). Each one occupies precious memory.</p>

<p>It's easy to see where RAM becomes a major consideration here. With the processors that do their work in Java, It is completely normal to see transient spikes of hundreds of megabytes of memory use on the Java heap in response to a single zooming-image-viewer request. The JVM will accommodate by dynamically increasing the heap size. From the operating system's perspective, the process is bloating up to a gigabyte in size and beyond, but there is nothing wrong &mdash; most of this is actually unused heap space.</p>

<p>The smaller the available heap space, the larger the source images, and the larger the number of simultaneous requests, the greater the likelihood of OutOfMemoryErrors. In production, it is highly recommended to use the <code>-Xmx</code> flag to increase the maximum heap size to the largest amount possible &mdash; for example, <code>-Xmx8g</code> for 8GB. And, by all means, use caching liberally on both the <a href="client-caching.html">client</a> and <a href="caches.html">server</a>.</p>

<h4>Storage</h4>

<p>Cantaloupe benefits from fast read performance in the underlying storage system, especially as source image size increases.</p>
